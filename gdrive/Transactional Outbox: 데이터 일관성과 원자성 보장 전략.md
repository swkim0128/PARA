제공된 소스들을 바탕으로 **Transactional Outbox 패턴**을 통해 \*\*DB 업데이트와 메시지 발행의 원자성(Atomicity)\*\*을 어떻게 보장하는지 심층적으로 논의하겠습니다.  
마이크로서비스 환경에서 가장 흔하고 치명적인 문제는 **'이중 쓰기(Dual Write)'** 문제입니다. 이는 서비스가 로컬 데이터베이스를 업데이트하고 동시에 메시지 브로커(Kafka, RabbitMQ 등)에 이벤트를 발행해야 할 때 발생합니다. Transactional Outbox 패턴은 이 두 작업을 단일 ACID 트랜잭션으로 묶어 데이터 무결성을 보장하는 표준적인 해결책입니다.

### 1\. 문제의 본질: 이중 쓰기(Dual Write)와 원자성의 부재

전통적인 방식에서는 서비스가 DB를 업데이트한 후 메시지를 발행합니다. 하지만 이 두 작업은 분리된 인프라(DB와 메시지 브로커)에서 일어나므로 원자성을 보장할 수 없습니다 1\.

* **시나리오 A (DB 커밋 후 메시지 전송 실패):** DB에는 데이터가 저장되었으나 브로커가 다운되거나 네트워크 오류로 메시지 발행에 실패하면, 다운스트림 서비스는 이벤트를 받지 못해 데이터 불일치가 발생합니다 2\.  
* **시나리오 B (메시지 전송 후 DB 롤백):** 메시지를 먼저 보내고 DB 트랜잭션이 실패하면, 실제로는 존재하지 않는 데이터에 대한 이벤트가 발행되어 '유령 레코드(Phantom Record)' 문제가 발생합니다 2\.

분산 트랜잭션(2PC)은 성능 저하와 현대적 메시지 브로커의 지원 부족으로 인해 실행 가능한 대안이 아닌 경우가 많습니다 3, 4\.

### 2\. 해결책: Transactional Outbox 패턴의 핵심 메커니즘

Transactional Outbox 패턴은 **메시지 전송을 DB 트랜잭션의 일부로 포함**시킴으로써 원자성을 확보합니다.

#### A. 원자적 쓰기 (Phase 1: Transactional Write)

이 패턴의 핵심은 비즈니스 데이터와 함께 **발행할 메시지를 동일한 데이터베이스 내의 Outbox 테이블에 저장**하는 것입니다 5, 6\.

* **단일 트랜잭션:** 비즈니스 로직(예: Order 테이블에 주문 저장)과 메시지 저장(예: Outbox 테이블에 이벤트 저장)이 하나의 로컬 데이터베이스 트랜잭션(@Transactional) 안에서 수행됩니다 6, 7\.  
* **보장된 원자성:** RDBMS의 ACID 특성 덕분에, 비즈니스 데이터가 커밋되면 Outbox 메시지도 반드시 커밋되고, 롤백되면 메시지도 함께 사라집니다 6, 8\. 즉, 메시지가 유실되거나 잘못 발행될 위험이 사라집니다 9\.

#### B. 비동기 릴레이 (Phase 2: Asynchronous Relay)

DB에 안전하게 저장된 메시지는 별도의 **메시지 릴레이(Message Relay)** 프로세스에 의해 메시지 브로커로 전송됩니다 5, 10\. 소스에서는 이를 구현하는 두 가지 주요 방식을 제시합니다.

* **폴링 발행자 (Polling Publisher):**  
* 주기적으로 Outbox 테이블을 조회(SELECT \* FROM outbox WHERE processed \= false)하여 미발행 메시지를 읽어 브로커로 전송하고, 완료 후 처리 상태를 업데이트하거나 삭제합니다 11, 12\.  
* **장점:** 구현이 간단하고 별도의 인프라가 필요 없습니다 11\.  
* **단점:** 폴링 주기에 따른 지연(Latency)이 발생하며, 데이터베이스에 부하를 줄 수 있습니다 11\.  
* **트랜잭션 로그 테일링 (Transaction Log Tailing / CDC):**  
* 데이터베이스의 트랜잭션 로그(MySQL Binlog, PostgreSQL WAL 등)를 실시간으로 감지하여 변경 사항을 추출합니다 11, 13\. **Debezium**과 같은 도구가 표준으로 사용됩니다 11, 14\.  
* **장점:** 거의 실시간에 가까운 처리가 가능하며, 애플리케이션이나 DB 성능에 영향을 주지 않습니다 11, 15\.  
* **단점:** 별도의 인프라(Kafka Connect 등)를 구축해야 하므로 운영 복잡도가 증가합니다 11, 16\.

### 3\. 데이터 일관성 보장과 특징

이 패턴을 적용함으로써 시스템은 다음과 같은 특성을 갖게 됩니다.

* **최소 한 번 전달 (At-Least-Once Delivery):** 메시지 릴레이가 메시지를 브로커에 전송한 후 DB에 '처리됨' 표시를 하기 전에 실패할 경우, 재시작 시 동일한 메시지를 다시 보낼 수 있습니다 17, 18\. 따라서 메시지 유실은 없지만 중복 전송될 수 있으므로, **수신 측(Consumer)은 반드시 멱등성(Idempotency)을 확보**해야 합니다 9, 17\.  
* **순서 보장:** Outbox 테이블에 저장된 순서(타임스탬프 또는 시퀀스)대로 메시지를 브로커에 발행하므로, 이벤트의 순서가 보장됩니다 19, 20\.  
* **결과적 일관성 (Eventual Consistency):** DB 업데이트와 메시지 발행 사이에 시차(Lag)가 존재하므로, 시스템은 즉각적 일관성 대신 결과적 일관성을 갖게 됩니다 9, 21\.

### 4\. 실제 구현 사례 (Spring Boot & Debezium)

소스에서는 Spring Boot와 JPA를 사용한 구현 예시를 제공합니다.

* 비즈니스 엔티티(Order)와 OutboxEvent 엔티티를 생성하고, 서비스 계층의 @Transactional 메서드 내에서 두 리포지토리를 모두 호출하여 저장합니다 22, 23\.  
* Debezium 커넥터를 설정하여 outbox 테이블의 변경 사항을 감지하고 Kafka 토픽으로 라우팅하도록 구성할 수 있습니다 24, 25\. 이때 Debezium의 EventRouter 변환(SMT)을 사용하면 복잡한 CDC 이벤트를 깔끔한 도메인 이벤트 형태로 변환하여 발행할 수 있습니다 26\.

### 요약

**Transactional Outbox 패턴**은 마이크로서비스 환경에서 **DB 업데이트와 메시지 발행을 원자적으로 처리**하기 위한 필수적인 패턴입니다. 로컬 트랜잭션을 통해 메시지 유실을 방지하고, 비동기 릴레이(Polling 또는 CDC)를 통해 메시지를 브로커로 안전하게 전달함으로써, 분산 시스템의 **데이터 일관성과 신뢰성**을 보장합니다 7, 27\.  
