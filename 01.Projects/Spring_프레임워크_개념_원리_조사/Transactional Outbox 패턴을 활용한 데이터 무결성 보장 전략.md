## 1\. Dual Write 문제와 데이터 유실 위험

**Dual Write 문제**란 분산 시스템에서 단일 작업 내에 **데이터베이스 쓰기**와 **메시지 발행**이라는 두 가지 서로 다른 인프라에 대한 쓰기 작업이 발생하는 상황을 말합니다1, 2\. 이 두 작업은 서로 다른 트랜잭션 범위를 가지기 때문에, 분산 트랜잭션(2PC)을 사용하지 않는 한 원자성을 보장할 수 없습니다3.  
이로 인해 다음과 같은 **데이터 유실 및 불일치 시나리오**가 발생합니다:

* **시나리오 A (DB 커밋 성공, 메시지 전송 실패):** 서비스가 DB에 데이터를 저장했으나, 네트워크 오류나 브로커 장애로 메시지 발행에 실패하는 경우입니다. 이 경우 다운스트림 서비스는 데이터 변경 사실을 알 수 없어 **이벤트가 유실**되고 시스템 간 데이터 불일치가 발생합니다4, 5\.  
* **시나리오 B (메시지 전송 성공, DB 롤백):** 메시지를 먼저 보내고 DB 트랜잭션을 커밋하려다 실패하는 경우입니다. 이 경우 실제로는 존재하지 않는 데이터에 대한 이벤트가 발행되어 \*\*유령 레코드(Phantom Record)\*\*가 생성되고 데이터 무결성이 깨집니다6.

전통적인 2단계 커밋(2PC)은 성능 저하와 가용성 문제, 그리고 현대적인 브로커나 NoSQL의 미지원 등으로 인해 마이크로서비스 환경에서는 권장되지 않습니다7, 8\.

## 2\. Transactional Outbox 패턴을 통한 해결

Transactional Outbox 패턴은 메시지 전송을 **데이터베이스 트랜잭션의 일부로 포함**시킴으로써 이 문제를 해결합니다.

* **원자적 쓰기 (Transactional Write):** 비즈니스 데이터를 저장할 때, 발행할 메시지를 동일한 데이터베이스 내의 **'Outbox' 테이블**에 삽입하는 작업을 하나의 로컬 트랜잭션으로 묶습니다9, 10\.  
* RDBMS의 ACID 특성 덕분에 비즈니스 데이터와 Outbox 메시지는 **동시에 커밋되거나 동시에 롤백**됩니다11, 12\.  
* 이를 통해 메시지 브로커가 다운되더라도 메시지는 DB에 안전하게 저장되므로 **데이터 유실 위험이 제거**됩니다13, 14\.

## 3\. 메시지 릴레이(Relay)와 신뢰성 확보

DB에 저장된 메시지를 실제로 메시지 브로커로 전송하는 역할은 별도의 **메시지 릴레이(Message Relay)** 프로세스가 담당합니다. 소스에서는 이를 구현하는 두 가지 주요 방식을 제시합니다.

* **폴링 발행기 (Polling Publisher):**  
* 주기적으로 Outbox 테이블을 쿼리하여 미발행 메시지를 읽어 전송하고, 전송이 완료되면 해당 메시지를 삭제하거나 처리됨으로 표시합니다15, 16\.  
* 구현이 간단하지만, DB에 부하를 줄 수 있고 폴링 주기에 따른 지연 시간이 발생할 수 있습니다16.  
* **트랜잭션 로그 테일링 (Log Tailing / CDC):**  
* 데이터베이스의 트랜잭션 로그(MySQL Binlog 등)를 실시간으로 읽어 변경 사항을 감지하는 **CDC(Change Data Capture)** 기술을 사용합니다17, 18\. **Debezium**과 같은 도구가 대표적입니다18, 19\.  
* 애플리케이션 성능에 영향을 주지 않으면서 실시간성을 보장할 수 있어 고성능 시스템에 적합합니다19.

## 4\. 보장 수준과 멱등성 (At-Least-Once & Idempotency)

Transactional Outbox 패턴은 메시지가 **최소 한 번(At-Least-Once)** 전달됨을 보장합니다13, 14\.

* **중복 전송 가능성:** 릴레이 프로세스가 메시지를 브로커에 보낸 후 DB 상태를 업데이트하기 전에 장애가 발생하면, 재시작 시 동일한 메시지가 다시 전송될 수 있습니다16, 20\.  
* **멱등성 필수:** 따라서 메시지를 수신하는 컨슈머는 반드시 \*\*멱등성(Idempotency)\*\*을 갖춰야 합니다21, 22\. 즉, 동일한 메시지를 여러 번 처리하더라도 시스템의 상태가 한 번 처리한 것과 같아야 합니다. 이를 위해 처리된 메시지 ID를 추적하는 별도의 테이블을 사용하는 방식이 권장됩니다22, 23\.

## 5\. 더 큰 맥락: Saga 및 CQRS의 기반 기술

Transactional Outbox 패턴은 단순히 메시지 전송을 보장하는 것을 넘어, **Saga 패턴**과 **CQRS 패턴**이 올바르게 작동하기 위한 필수적인 기반 기술입니다.

* **Saga 패턴:** Saga의 각 단계에서 로컬 트랜잭션을 완료하고 다음 단계를 트리거하는 이벤트를 발행할 때, Outbox 패턴을 사용하여 이벤트 발행의 신뢰성을 보장해야 Saga 전체의 정합성이 유지됩니다24, 25\.  
* **CQRS 패턴:** 명령(Command) 모델의 변경 사항을 조회(Query) 모델로 전파할 때, Outbox 패턴은 데이터 누락 없는 동기화를 보장하여 결과적 일관성(Eventual Consistency)을 달성하게 합니다26.

결론적으로, Transactional Outbox 패턴은 분산 시스템에서 2PC를 사용하지 않고도 **DB 업데이트와 메시지 발행의 원자성을 보장**하여 **데이터 유실을 방지**하는 가장 효과적이고 실용적인 전략입니다5, 27\.  
