## 1\. 발신자 (Sender / Business Service)

발신자는 비즈니스 로직을 수행하고 이벤트를 발생시키는 \*\*마이크로서비스(Business Service)\*\*입니다.

* **역할:** 비즈니스 데이터를 생성하거나 수정하는 동시에, 해당 변경 사항을 알리는 메시지(이벤트)를 생성합니다.  
* **핵심 동작:** 가장 중요한 점은 비즈니스 엔티티(예: Order)를 저장하는 작업과 메시지를 Outbox에 저장하는 작업을 **단일 로컬 데이터베이스 트랜잭션**으로 묶어서 실행한다는 것입니다1, 2\.  
* **효과:** 이를 통해 비즈니스 데이터 처리가 성공하면 메시지 저장도 반드시 성공하고, 실패하면 메시지도 함께 롤백되는 \*\*원자성(Atomicity)\*\*을 보장합니다3, 4\.

## 2\. 데이터베이스 및 아웃박스 테이블 (Database & Message Outbox)

데이터베이스는 비즈니스 데이터와 메시지를 함께 저장하는 저장소이며, **아웃박스 테이블**은 발행 대기 중인 메시지를 임시로 보관하는 핵심 컴포넌트입니다.

* **구조:** 관계형 데이터베이스(RDBMS)의 경우 Outbox라는 별도의 테이블을 생성하며, NoSQL의 경우 각 레코드(문서)의 속성으로 outbox를 포함시키기도 합니다1.  
* **스키마 구성:** 소스에 따르면 아웃박스 테이블은 일반적으로 다음과 같은 컬럼을 포함합니다:  
* id: 이벤트의 고유 식별자 (중복 방지 및 멱등성 처리에 사용)5, 6\.  
* aggregate\_type & aggregate\_id: 이벤트가 발생한 도메인 엔티티를 식별하는 정보5, 6\.  
* type: 이벤트의 종류 (예: ORDER\_CREATED)6.  
* payload: 실제 메시지 내용 (주로 JSON 형태)7, 6\.  
* created\_at & processed: 메시지 생성 시간 및 발행 여부 상태6.

## 3\. 메시지 릴레이 (Message Relay)

메시지 릴레이는 아웃박스 테이블에 저장된 메시지를 읽어 실제 \*\*메시지 브로커(Kafka, RabbitMQ 등)\*\*로 전송하는 별도의 프로세스입니다1, 8\. 이 컴포넌트의 구현 방식은 크게 두 가지로 나뉩니다.

### A. 폴링 발행기 (Polling Publisher)

* **방식:** 주기적으로 DB에 쿼리(SELECT \* FROM outbox WHERE processed \= false)를 날려 미발행 메시지를 조회하고 전송한 뒤, 처리 완료 상태로 업데이트하거나 삭제합니다9, 10\.  
* **장단점:** 구현이 간단하고 별도 인프라가 필요 없지만, 폴링 주기에 따른 지연(Latency)이 발생하고 데이터베이스에 부하를 줄 수 있습니다10.

### B. 트랜잭션 로그 테일링 (Transaction Log Tailing / CDC)

* **방식:** 데이터베이스의 트랜잭션 로그(MySQL binlog 등)를 실시간으로 감지하여 변경 사항을 추출합니다. **Debezium**과 같은 도구가 대표적입니다11, 3, 10\.  
* **장단점:** 애플리케이션의 성능에 영향을 주지 않으면서 실시간성을 보장하지만, 카프카 커넥트(Kafka Connect) 등 추가적인 인프라 구축이 필요하여 복잡도가 높습니다10.

## 4\. 거시적 맥락: 데이터 일관성 및 신뢰성 보장

이러한 구성 요소들은 Transactional Outbox 패턴이라는 큰 맥락에서 다음과 같은 목표를 달성하기 위해 협력합니다.

* **2PC(2단계 커밋) 대체:** 데이터베이스와 메시지 브로커 간의 분산 트랜잭션을 사용하지 않고도, 로컬 트랜잭션만으로 데이터 무결성을 달성합니다12, 13\.  
* **최소 한 번 전달 (At-Least-Once Delivery):** 메시지 릴레이가 브로커 전송 후 DB 업데이트 전에 실패하더라도, 재시작 시 아웃박스 테이블에 남아있는 메시지를 다시 보내므로 메시지 유실이 없습니다14, 4\.  
* **순서 보장:** 메시지 릴레이는 아웃박스 테이블에 저장된 순서(타임스탬프 또는 시퀀스)대로 브로커에 메시지를 발행하므로, 이벤트의 순서를 보장할 수 있습니다15.

결론적으로 Transactional Outbox 패턴은 **발신자**가 로컬 트랜잭션을 통해 **아웃박스 테이블**에 메시지를 안전하게 보관하고, **메시지 릴레이**가 이를 비동기적으로 브로커에 전달하는 구조를 통해 마이크로서비스 간의 데이터 일관성을 강력하게 보장합니다.  
