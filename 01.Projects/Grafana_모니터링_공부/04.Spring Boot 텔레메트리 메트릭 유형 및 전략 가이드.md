## 1. Micrometer의 핵심 메트릭 유형과 활용 전략

Spring Boot 텔레메트리 설정의 핵심인 **Micrometer**는 애플리케이션의 상태를 측정하기 위해 다양한 '미터(Meter)' 프리미티브를 제공합니다. 소스들은 각 유형이 특정 운영 질문에 답하기 위해 설계되었음을 강조합니다.

- **카운터 (Counters):**

        - **특성:** 오직 증가만 하는 단조 증가(Monotonically increasing) 값입니다.  
    - **용도:** 총 요청 수, 완료된 작업 수, 발생한 에러 수 등을 측정합니다.  
    - **텔레메트리 맥락:** Prometheus와 결합 시 `rate()` 함수를 사용하여 **초당 요청 수(RPS)**와 같은 변화율을 계산하는 데 필수적입니다.

- **게이지 (Gauges):**

        - **특성:** 임의로 오르내릴 수 있는 값으로, 특정 시점의 상태 스냅샷을 나타냅니다.  
    - **용도:** 현재 메모리 사용량, 실행 중인 스레드 수, 대기열(Queue)의 크기, 컬렉션의 크기 등을 모니터링합니다.  
    - **설정:** `MeterRegistry`를 통해 `List::size`와 같은 메서드 참조를 직접 연결하여 실시간 상태를 반영하도록 설정합니다.

- **타이머 (Timers):**

        - **특성:** 짧은 지연 시간을 측정하며, 이벤트의 **빈도(Count)**와 **총 소요 시간(Total Time)**을 동시에 추적합니다.  
    - **용도:** HTTP 요청 처리 시간, 데이터베이스 쿼리 시간 등을 측정합니다.  
    - **고급 설정:** 단순 평균뿐만 아니라 **최대 시간(Max)** 및 **백분위수(Percentile)** 분포를 제공하여 성능 병목 현상을 식별하는 데 가장 중요한 지표입니다.

- **분포 요약 (Distribution Summaries):**

        - **특성:** 타이머와 유사하지만 시간 이외의 값(크기, 무게 등)의 분포를 추적합니다.  
    - **용도:** 요청 페이로드의 크기(bytes), 배치 작업 처리 건수 등을 측정합니다.

## 2. 선언적 측정과 프로그래밍적 측정의 조화

Spring Boot 텔레메트리 설정은 개발자가 비즈니스 로직에 최소한의 개입으로 메트릭을 수집할 수 있도록 두 가지 접근 방식을 모두 지원합니다.

- **선언적 접근 (AOP & Annotations):**

    ◦ `spring-boot-starter-aop` 의존성을 추가하면 `@Timed`나 `@Counted` 어노테이션을 사용하여 메서드 레벨의 모니터링을 쉽게 적용할 수 있습니다.    ◦ 이는 비즈니스 로직을 오염시키지 않고 특정 메서드의 실행 시간이나 호출 빈도를 측정하는 데 유용합니다.

- **프로그래밍적 접근 (MeterRegistry):**

    ◦ 복잡한 로직이나 동적인 태그가 필요한 경우, `MeterRegistry`를 주입받아 `Counter.builder()`나 `Gauge.builder()`를 사용하여 직접 메트릭을 생성하고 등록합니다.

## 3. 히스토그램(Histogram) vs 요약(Summary): 분산 시스템을 위한 전략적 선택

Spring Boot 텔레메트리 설정 시, 지연 시간(Latency)을 측정하는 방식은 데이터의 정확도와 시스템 부하에 큰 영향을 미칩니다.

- **클라이언트 측 집계 (Summaries):** 애플리케이션 내부에서 분위수(Quantile)를 미리 계산합니다. 단일 인스턴스에는 정확하지만, 여러 인스턴스의 데이터를 합쳐서 평균을 낼 수 없으므로(Cannot be aggregated) 클러스터 환경에는 적합하지 않습니다.

- **서버 측 집계 (Histograms):** 데이터를 버킷(Bucket) 단위로 나누어 수집합니다. 이는 Prometheus 서버에서 `histogram_quantile()` 함수를 사용하여 여러 인스턴스의 데이터를 집계할 수 있으므로, **현대적인 분산 시스템 모니터링에 권장되는 방식**입니다.

• **설정:** Spring Boot에서는 `management.metrics.distribution.percentiles-histogram.http.server.requests=true` 속성을 통해 HTTP 요청에 대한 히스토그램 수집을 활성화할 수 있습니다.

## 4. 차원(Dimensionality)과 카디널리티(Cardinality) 관리

Micrometer는 계층적 이름(Hierarchical naming) 대신 **태그(Tags/Labels)** 기반의 차원적 모니터링을 지향합니다. 이는 텔레메트리 설정의 유연성을 높이지만, 관리 위험 요소도 동반합니다.

- **차원적 메트릭:** `http.server.requests`라는 하나의 메트릭 이름에 `method=GET`, `status=200`, `uri=/api/users`와 같은 태그를 붙여 데이터를 세분화합니다. 이를 통해 "모든 POST 요청의 합계"나 "특정 URI의 에러율" 등을 유연하게 쿼리할 수 있습니다.

- **카디널리티 폭발 방지:** 사용자 ID나 동적 쿼리 파라미터와 같이 고유 값이 무수히 많은 데이터를 태그로 사용하면, 생성되는 시계열 데이터가 폭증하여 모니터링 시스템(Prometheus)의 메모리를 고갈시킬 수 있습니다.

- **제어 전략:** Spring Boot의 `MeterFilter`를 사용하여 불필요한 태그를 제거하거나, 특정 메트릭의 등록을 거부(Deny)하거나, 허용되는 최대 메트릭 수를 제한하는 방어적 설정이 필수적입니다.

## 요약

Spring Boot 텔레메트리 설정 맥락에서 **메트릭 유형**은 단순한 데이터 타입이 아닙니다. 이는 **1) 카운터와 게이지를 통한 상태 및 속도 측정, 2) 타이머와 히스토그램을 통한 성능 및 분포 분석, 3) 태그를 통한 다차원적 데이터 모델링**을 포괄하며, 이를 통해 운영자는 시스템의 동작을 **"블랙박스"가 아닌 "투명한 유리상자"처럼 관측**할 수 있게 됩니다.
