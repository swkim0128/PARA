---
type: PHP
archive: false
---
## 산술 연산자

---

### 연산자(operator)

PHP는 다양한 연산을 위해 많은 종류의 연산자를 제공하고 있습니다.

  

### 산술 연산자(arithmetic operator)

산술 연산자는 사칙 연산을 다루는 가장 기본적이면서도 많이 사용하는 연산자입니다.

산술 연산자는 모두 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽입니다.

  

> [!important]  
> 항이란 해당 연산의 실행이 가능하기 위해 필요한 값이나 변수를 의미합니다.따라서 이항 연산자란 해당 연산의 실행을 위해서 두 개의 값이나 변수가 필요한 연산자를 의미합니다.  

  

|산술 연산자|설명|
|---|---|
|+|왼쪽의 피연산자에 오른쪽의 피연산자를 더함.|
|-|왼쪽의 피연산자에서 오른쪽의 피연산자를 뺌.|
|*|왼쪽의 피연산자에 오른쪽의 피연산자를 곱함.|
|/|왼쪽의 피연산자를 오른쪽의 피연산자로 나눔.|
|%|왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 반환함.|
|**|왼쪽 피연산자의 값에 오른쪽 피연산자의 값을 제곱함. (PHP 5.6에서 추가됨)|

```PHP
$num_01 = 10;
$num_02 = 4;

echo "+ 연산자에 의한 결괏값은 ".($num_01 + $num_02)."입니다.<br>"; // 14
echo "- 연산자에 의한 결괏값은 ".($num_01 - $num_02)."입니다.<br>"; // 6
echo "* 연산자에 의한 결괏값은 ".($num_01 * $num_02)."입니다.<br>"; // 40
echo "/ 연산자에 의한 결괏값은 ".($num_01 / $num_02)."입니다.<br>"; // 2.5
echo "% 연산자에 의한 결괏값은 ".($num_01 % $num_02)."입니다.";     // 2
```

  

### 연산자의 우선순위(operator precedence)와 결합 방향(associativity)

연산자의 우선순위는 하나의 수식 내에 여러 연산자가 함께 등장할 때, 어느 연산자가 먼저 처리될 것인가를 결정합니다.

다음 그림은 가장 높은 우선순위를 가지고 있는 괄호(()) 연산자를 사용하여 연산자의 처리 순서를 변경하는 것을 보여줍니다.

[![](http://www.tcpschool.com/lectures/img_js_precedence.png)](http://www.tcpschool.com/lectures/img_js_precedence.png)

연산자의 결합 방향은 수식 내에 우선순위가 같은 연산자가 둘 이상 있을 때, 먼저 어느 연산을 수행할 것인가를 결정합니다.

[![](http://www.tcpschool.com/lectures/img_js_associativity.png)](http://www.tcpschool.com/lectures/img_js_associativity.png)

  

### PHP 연산자의 우선순위표

PHP에서 연산자의 우선순위와 결합 방향은 다음과 같습니다.

  

|우선순위|연산자|설명|결합 방향|
|---|---|---|---|
|1|new|객체의 생성|-|
||clone|객체의 복제|-|
|2|[]|배열|왼쪽에서 오른쪽으로|
|3|++|증가 연산자|-|
||--|감소 연산자|-|
|4|(타입)|타입 캐스트 연산자|-|
||~|비트 NOT 연산자|-|
||-|음의 부호 (단항 연산자)|-|
|5|instanceof|객체|-|
|6|!|논리 NOT 연산자|오른쪽에서 왼쪽으로|
|7|*|곱셈 연산자|왼쪽에서 오른쪽으로|
||/|나눗셈 연산자|왼쪽에서 오른쪽으로|
||%|나머지 연산자|왼쪽에서 오른쪽으로|
|8|+|덧셈 연산자|왼쪽에서 오른쪽으로|
||-|뺄셈 연산자|왼쪽에서 오른쪽으로|
|9|<<|비트 왼쪽 시프트 연산자|왼쪽에서 오른쪽으로|
||>>|비트 오른쪽 시프트 연산자|왼쪽에서 오른쪽으로|
|10|<|관계 연산자(보다 작은)|-|
||<=|관계 연산자(보다 작거나 같은)|-|
||>|관계 연산자(보다 큰)|-|
||>=|관계 연산자(보다 크거나 같은)|-|
||<>|관계 연산자(와 같지 않은)|-|
|11|==|관계 연산자(와 같은)|-|
||===|관계 연산자(와 같고 같은 타입)|-|
||!=|관계 연산자(와 같지 않은)|-|
||!==|관계 연산자(와 같지 않거나 다른 타입)|-|
|12|&|비트 AND 연산자|왼쪽에서 오른쪽으로|
|13|^|비트 XOR 연산자|왼쪽에서 오른쪽으로|
|14|\||비트 OR 연산자|왼쪽에서 오른쪽으로|
|15|&&|논리 AND 연산자|왼쪽에서 오른쪽으로|
|16|\||논리 OR 연산자|왼쪽에서 오른쪽으로|
|17|? :|삼항 연산자|오른쪽에서 왼쪽으로|
|18|=|대입 연산자|오른쪽에서 왼쪽으로|
||+=|복합 대입 연산자(덧셈)|오른쪽에서 왼쪽으로|
||-=|복합 대입 연산자(뺄셈)|오른쪽에서 왼쪽으로|
||*=|복합 대입 연산자(곱셈)|오른쪽에서 왼쪽으로|
||/=|복합 대입 연산자(나눗셈)|오른쪽에서 왼쪽으로|
||%=|복합 대입 연산자(나머지)|오른쪽에서 왼쪽으로|
||.=|복합 대입 연산자(문자열 추가)|오른쪽에서 왼쪽으로|
||<<=|복합 대입 연산자(비트 왼쪽 시프트)|오른쪽에서 왼쪽으로|
||>>=|복합 대입 연산자(비트 오른쪽 시프트)|오른쪽에서 왼쪽으로|
||&=|복합 대입 연산자(비트 AND)|오른쪽에서 왼쪽으로|
||\|=|복합 대입 연산자(비트 OR)|오른쪽에서 왼쪽으로|
||^=|복합 대입 연산자(비트 XOR)|오른쪽에서 왼쪽으로|
|19|and|논리 AND 연산자|왼쪽에서 오른쪽으로|
|20|xor|논리 XOR 연산자|왼쪽에서 오른쪽으로|
|21|or|논리 OR 연산자|왼쪽에서 오른쪽으로|
|22|,|쉼표 연산자|왼쪽에서 오른쪽으로|

  

## 대입 연산자

---

### 대입 연산자(assignment operator)

대입 연산자는 변수에 값을 대입할 때 사용하는 이항 연산자이며, 피연산자들의 결합 방향은 오른쪽에서 왼쪽입니다.

|대입 연산자|설명|
|---|---|
|=|왼쪽의 피연산자에 오른쪽의 피연산자를 대입함.|

  

### 복합 대입 연산자

PHP에서는 대입 연산자와 산술 연산자 등을 결합한 다양한 복합 대입 연산자를 제공합니다.

복합 대입 연산자는 모두 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 오른쪽에서 왼쪽입니다.

|복합 대입 연산자|설명|
|---|---|
|+=|왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후, 왼쪽의 피연산자에 대입함.|
|-=|왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀 후, 왼쪽의 피연산자에 대입함.|
|*=|왼쪽의 피연산자에 오른쪽의 피연산자를 곱한 후, 왼쪽의 피연산자에 대입함.|
|/=|왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 왼쪽의 피연산자에 대입함.|
|%=|왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 왼쪽의 피연산자에 대입함.|
|.=|왼쪽 피연산자의 문자열에 오른쪽 피연산자의 문자열을 추가한 후, 왼쪽의 피연산자에 대입함.|
|<<=|왼쪽의 피연산자의 비트를 오른쪽의 피연산자만큼 전부 왼쪽으로 이동시킨 후, 그 결과를 왼쪽의 피연산자에 대입함|
|>>=|왼쪽의 피연산자의 비트를 부호를 유지하면서 오른쪽의 피연산자만큼 전부 오른쪽으로 이동시킨 후, 그 결과를 왼쪽의 피연산자에 대입함.|
|&=|왼쪽의 피연산자와 오른쪽의 피연산자의 논리식이 모두 true면 왼쪽 피연산자에 true을 대입하고, 그 외에는 false을 대입함.|
|\|=|왼쪽의 피연산자나 오른쪽의 피연산자의 논리식 중 하나라도 true면 왼쪽 피연산자에 true을 대입하고, 그 외에는 false을 대입함.|
|^=|왼쪽 피연산자의 논리식과 오른쪽 피연산자의 논리식이 서로 다르면 왼쪽 피연산자에 true을 대입하고, 그 외에는 false을 대입함.|

```PHP
$num_01 = 7;
$num_02 = 7;
$num_03 = 7;

echo "- 연산자에 의한 결괏값은 ".($num_01 = $num_01 - 5)."입니다.<br>"; // 2
echo "-= 연산자에 의한 결괏값은 ".($num_02 -= 5)."입니다.<br>";         // 2
echo "=- 연산자에 의한 결괏값은 ".($num_03 =- 5)."입니다.";             // -5
```

  

## 증감 연산자

---

### 증감 연산자(increment and decrement operator)

증감 연산자는 피연산자를 1씩 증가 혹은 감소시킬 때 사용하는 연산자입니다.

이 연산자는 피연산자가 단 하나뿐인 단항 연산자입니다.

증감 연산자는 해당 연산자가 피연산자의 어느 쪽에 위치하는가에 따라 연산의 순서 및 결과가 달라집니다.

|증감 연산자|설명|
|---|---|
|++$var|먼저 피연산자의 값을 1 증가시킨 후에 해당 연산을 수행함.|
|$var++|먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 증가시킴.|
|--$var|먼저 피연산자의 값을 1 감소시킨 후에 해당 연산을 수행함.|
|$var--|먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 감소시킴.|

```PHP
$num_01 = 7;
$num_02 = 7; 

echo "++\\$num_01 에 의한 결괏값은 ".(++$num_01 - 5)."이고, 변수의 값은 {$num_01}로 변했습니다.<br>";
echo "\\$num_02++ 에 의한 결괏값은 ".($num_02++ - 5)."이고, 변수의 값은 {$num_02}로 변했습니다.";
```

  

위의 예제에서 첫 번째 연산은 변수 $num_01의 값을 먼저 1 증가시킨 후에 전체 연산을 수행합니다.

하지만 두 번째 연산은 먼저 모든 연산을 끝마친 후에 변수 $num_02의 값을 1 증가시킵니다.

따라서 두 번째 연산에서 변수 $num_02의 증가는 전체 연산에 어떠한 영향도 미치지 않습니다.

  

### 증감 연산자의 연산 순서

증감 연산자는 피연산자의 어느 쪽에 위치하는가에 따라 연산의 순서가 달라집니다.

다음 예제는 증감 연산자의 연산 순서를 살펴보기 위한 예제입니다.

  

```PHP
$x = 10;
$y = $x-- + 5 + --$x;

echo "변수 \\$x 의 값은 ".$x."이고, 변수 \\$y 의 값은 ".$y."으로 변경되었습니다.";
```

  

[![](http://www.tcpschool.com/lectures/img_js_decrement.png)](http://www.tcpschool.com/lectures/img_js_decrement.png)

① : 첫 번째 감소 연산자(decrement operator)는 피연산자의 뒤쪽에 위치하므로, 덧셈 연산이 먼저 수행됩니다.

② : 덧셈 연산이 수행된 후에 감소 연산이 수행됩니다. ($x의 값 : 9)

③ : 두 번째 감소 연산자는 피연산자의 앞쪽에 위치하므로, 덧셈 연산보다 먼저 수행됩니다. ($x의 값 : 8)

④ : 감소 연산이 수행된 후에 덧셈 연산이 수행됩니다.

⑤ : 마지막으로 변수 $y에 결괏값의 대입 연산이 수행됩니다. ($y의 값 : 23)

  

## 비교 연산자

---

### 비교 연산자(comparison operator)

비교 연산자는 피연산자 사이의 상대적인 크기를 판단하여, 참(true)과 거짓(false)을 반환합니다.

비교 연산자는 모두 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽입니다.

  

|비교 연산자|설명|
|---|---|
|==|왼쪽의 피연산자와 오른쪽의 피연산자가 같으면 참을 반환함.|
|===|왼쪽의 피연산자와 오른쪽의 피연산자가 같고, 같은 타입이면 참을 반환함. (PHP 4에서 추가됨)|
|!=|왼쪽의 피연산자와 오른쪽의 피연산자가 같지 않으면 참을 반환함.|
|<>|왼쪽의 피연산자와 오른쪽의 피연산자가 같지 않으면 참을 반환함.|
|!==|왼쪽의 피연산자와 오른쪽의 피연산자가 같지 않거나, 타입이 다르면 참을 반환함. (PHP 4에서 추가됨)|
|<|왼쪽의 피연산자가 오른쪽의 피연산자보다 작으면 참을 반환함.|
|<=|왼쪽의 피연산자가 오른쪽의 피연산자보다 작거나 같으면 참을 반환함.|
|>|왼쪽의 피연산자가 오른쪽의 피연산자보다 크면 참을 반환함.|
|>=|왼쪽의 피연산자가 오른쪽의 피연산자보다 크거나 같으면 참을 반환함.|

> [!important]  
> !=와 <> 연산자는 정확히 같은 동작을 하며, 연산자의 우선순위에서만 차이가 발생합니다.  

  

```PHP
$num_01 = 3;
$num_02 = 3.0;
$num_03 = 3;

var_dump($num_01 == $num_02);  // true
var_dump($num_01 === $num_02); // false
var_dump($num_01 != $num_03);  // false
```

  

위의 예제에서 변수 $num_01과 $num_02의 값은 3으로 서로 같지만, 타입은 각각 정수와 실수로 서로 다릅니다.

따라서 동등 연산자(==, equal)와 일치 연산자(===, strict equal)의 결과가 다르게 반환됩니다.

  

### 다양한 타입의 비교

PHP에서는 다양한 타입의 값을 서로 비교해야 할 때 다음 규칙에 따라 비교합니다.

  

|피연산자1|피연산자2|비교 규칙|
|---|---|---|
|bool, null|모두|둘 다 불리언으로 변환한 후 비교함. (false < true)|
|string,  <br>resource,  <br>integer, float|string,  <br>resource,  <br>integer, float|숫자로 시작하는 문자열과 리소스는 숫자로 변환한 후 비교함.|
|object|object|내장 클래스는 자신의 비교 함수를 정의할 수 있으나, 다른 클래스끼리 비교할 수는 없음.|
|array|array|배열끼리의 비교는 같은 키를 가지는 값을 서로 비교함.  <br>이때 피연산자1 배열의 키가 피연산자2 배열에 존재하지 않으면 비교할 수 없으며, 배열 요소의 수가 적은 쪽이 작은 거로 판단됨.|
|array|모두|배열이 항상 큰 거로 판단됨.|
|object|모두|객체가 항상 큰 거로 판단됨.|

```PHP
① var_dump(0 < true);           // true
② var_dump("123abc" == 123);    // true
③ var_dump("123abc" === 123);   // false

$arr_01 = array("a" => 10);
$arr_02 = array("a" => 5);
$arr_03 = array("a" => 5, "c" => 7);

④ var_dump($arr_01 >= $arr_02); // true
⑤ var_dump($arr_01 >= $arr_03); // false
⑥ var_dump("문자열" < $arr_01); // true
```

  

## 논리 연산자

---

### 논리 연산자(logical operator)

논리 연산자는 논리식을 판단하여, 참(true)과 거짓(false)을 반환합니다.

and, or, xor 연산자는 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽입니다.

! 연산자는 피연산자가 단 하나뿐인 단항 연산자이며, 피연산자의 결합 방향은 오른쪽에서 왼쪽입니다.

  

|논리 연산자|설명|
|---|---|
|and|논리식이 모두 참이면 참을 반환함. (AND 연산)|
|or|논리식 중에서 하나라도 참이면 참을 반환함. (OR 연산)|
|xor|논리식이 서로 다르면 참을 반환함. (XOR 연산)|
|&&|논리식이 모두 참이면 참을 반환함. (AND 연산)|
|\||논리식 중에서 하나라도 참이면 참을 반환함. (OR 연산)|
|!|논리식의 결과가 참이면 거짓을, 거짓이면 참을 반환함. (NOT 연산)|

> [!important]  
> and와 && 연산자, or와 || 연산자는 정확히 같은 동작을 하며, 연산자의 우선순위에서만 차이가 발생합니다.  

  

|A|B|A and B (A && B)|A or B (A \| B)|A xor B|!A|
|---|---|---|---|---|---|
|true|true|true|true|false|false|
|true|false|false|true|true|false|
|false|true|false|true|true|true|
|false|false|false|false|false|true|

  

## 비트 연산자

---

### 비트 연산자(bitwise operator)

비트 연산자는 논리 연산자와 비슷하지만, 비트(bit) 단위로 논리 연산을 수행합니다.

또한, 비트 단위로 전체 비트를 왼쪽이나 오른쪽으로 이동시킬 때도 사용합니다.

  

|비트 연산자|설명|
|---|---|
|&|대응되는 비트가 모두 1이면 1을 반환함. (비트 AND 연산)|
|\||대응되는 비트 중에서 하나라도 1이면 1을 반환함. (비트 OR 연산)|
|^|대응되는 비트가 서로 다르면 1을 반환함. (비트 XOR 연산)|
|~|비트를 1이면 0으로, 0이면 1로 반전시킴. (비트 NOT 연산)|
|<<|지정한 수만큼 비트를 전부 왼쪽으로 이동시킴. (left shift 연산)|
|>>|부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동시킴. (right shift 연산)|

  

## 기타 연산자

---

### 삼항 연산자(ternary operator)

삼항 연산자는 유일하게 피연산자를 세 개나 가지는 조건 연산자입니다.

삼항 연산자의 문법은 다음과 같습니다.

  

> [!important]  
> 문법조건식 ? 반환값1 : 반환값2  

  

### 문자열 연산자(string operator)

PHP에서 문자열 연산자(.)를 사용하여 문자열을 연결할 수 있습니다.

이 연산자는 얼핏 보기에는 연산자가 아닌 것처럼 보이지만 양쪽에 위치한 두 문자열을 연결해 주는 역할을 합니다.

또한, echo() 함수에서는 쉼표 연산자(,)를 이용하여 문자열을 연결할 수 있습니다.

```PHP
$str_01 = "PHP 수업";
$str_02 = "에 오신것을 환영합니다!";

echo "두 문자열을 합친 문자열은 '".($str_01.$str_02)."'입니다.<br>";
echo $str_01, $str_02;
```

  

### 배열 합집합 연산자(array union operator)

배열 합집합 연산자(+)는 피연산자로 오는 두 배열의 합집합을 반환합니다.

왼쪽 피연산자로 오는 배열의 키값은 유지하면서, 거기에 맞춰 오른쪽 피연산자로 오는 배열을 덧붙이는 방식을 취합니다.

따라서 같은 키에 대한 값에는 왼쪽 피연산자로 오는 배열의 값이 저장됩니다.

```PHP
$arr_01 = array("1st" => "PHP", "2nd" => "MySQL");
$arr_02 = array("1st" => "HTML", "2nd" => "CSS", "3rd" => "JavaScript");

$result_01 = $arr_01 + $arr_02; // [PHP, MySQL, JavaScript]
var_dump($result_01);
$result_02 = $arr_02 + $arr_01; // [HTML, CSS, JavaScript]
var_dump($result_02);
```

  

위의 예제에서 두 배열의 첫 번째와 두 번째 요소의 키값이 서로 같습니다.

이때 어느 집합이 앞에 위치하는가에 따라 합집합 연산의 결과가 달라지는 것을 확인할 수 있습니다.

다음 예제는 연관 배열이 아닌 인덱스를 가지는 배열에서 배열 합집한 연산을 하는 예제입니다.

```PHP
$arr_01 = array("PHP", "MySQL");
$arr_02 = array("HTML", "CSS", "JavaScript");

$result_01 = $arr_01 + $arr_02; // [PHP, MySQL, JavaScript]
var_dump($result_01);
$result_02 = $arr_02 + $arr_01; // [HTML, CSS, JavaScript]
var_dump($result_02);
```

  

### instanceof 연산자

instanceof 연산자는 다음과 같은 사항을 확인하고자 할 때 사용할 수 있습니다.

1. 해당 변수가 어떤 클래스(class)에서 생성된 객체(object)인지를 확인할 때

2. 해당 변수가 부모 클래스(parent class)에서 상속받은 클래스인지를 확인할 때

3. 해당 변수가 클래스의 인스턴스(instance)인지 아닌지를 확인할 때

4. 해당 변수가 인터페이스(interface)로 구현한 클래스의 객체 인스턴스(object instance)인지 아닌지를 확인할 때

  

```PHP
interface Interface01

{
}
class Class01

{
}
class Class02 extends Class01 implements Interface01
{
}

/* 어떤 클래스(class)에서 생성된 객체(object)인지를 확인할 때 */
$var_01 = new Class01; // Class01 클래스 객체를 생성함.
var_dump($var_01 instanceof Class01);     // true
var_dump($var_01 instanceof Class02);     // false

/* 부모 클래스(parent class)에서 상속받은 클래스인지를 확인할 때 */
$var_02 = new Class02; // Class02 클래스 객체를 생성함.
var_dump($var_02 instanceof Class01);     // true
var_dump($var_02 instanceof Class02);     // true

/* 클래스의 인스턴스(instance)인지 아닌지를 확인할 때 */
$var_03 = new Class01; // Class01 클래스 객체를 생성함.
var_dump(!($var_03 instanceof Class02));  // true

/* 인터페이스(interface)로 구현한 클래스의 객체 인스턴스(object instance)인지 아닌지를 확인할 때 */
$var_04 = new Class02; // Class02 클래스 객체를 생성함.
var_dump($var_04 instanceof Class02);     // true
var_dump($var_04 instanceof Interface01); // true
```