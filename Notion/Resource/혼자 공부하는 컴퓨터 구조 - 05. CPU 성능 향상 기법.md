---
type: ComputerArchitecture
archive: false
---
## 05.1 빠른 CPU를 위한 설계 기법

### 클럭

클럭 속도는 헤르츠(Hz) 단위로 측정합니다.

  

### 코어와 멀티코어

코어는 CPU의 핵심 부분입니다. 하나의 코어는 한 번에 한 가지 명령어만 처리할 수 있습니다. 멀티코어 프로세서는 둘 이상의 코어를 가지고 있으므로 CPU를 말합니다.

  

### 스레드와 멀티스레드

### 스레드와 멀티스레드

스레드는 프로세스 내부에서 실행되는 여러 실행 흐름의 단위입니다. 멀티스레드는 여러 개의 스레드를 가질 수 있는 프로그램입니다. 멀티스레드 프로그램은 한 번에 여러 가지 작업을 처리할 수 있으므로 일반적으로 더 빠르게 실행됩니다.

**하드웨어적 스레드**

‘하나의 코어가 동시에 처리하는 명령어 단위’를 의미합니다.

**소프트웨어적 스레드**

‘하나의 프로그램에서 독립적으로 실행되는 단위’를 의미합니다. 프로그래밍 언어나 운영체제를 학습할 때 접하는 스레드는 보통 이렇게 소프트웨어적으로 정의된 스레드를 의미합니다.

**멀티스레드 프로세서**

가장 중요한 핵심은 레지스터입니다. 하나의 코어에서 여러 명령어를 동시에 처리하려면 하나의 명령어를 처리하는 데 필요한 레지스터보다 더 많은 레지스터가 필요합니다. 많은 레지스터를 통해 하나의 코어에서 여러 개의 명령어를 동시에 실행할 수 있으며, 이러한 하드웨어 스레드를 `논리 프로세서`라고 합니다.

## 05.2 명령어 병렬 처리 기법

### 명령어 파이프라인

명령어 처리 과정은 일반적으로 다음과 같이 나눌 수 있습니다.

1. 명령어 인출(Instruction Fetch)
2. 명령어 해석(Instruction Decode)
3. 명령어 실행(Execute Instruction)
4. 결과 저장(Write Back)

명령어 파이프라이닝은 명령어를 파이프라인에 넣고 동시에 처리하는 기법입니다. 이 기법은 CPU에서 명령어를 처리할 때 사용됩니다. 명령어 파이프라인은 명령어를 여러 단계로 나누어 처리하는 방법으로, 이를 통해 하나의 명령어가 처리될 때까지 기다리지 않고 여러 개의 명령어를 동시에 처리할 수 있습니다. 이 방법을 사용하면 CPU의 성능을 향상시킬 수 있습니다.

```Mermaid
flowchart LR	
	pipeline_hazard[파이프라인 위험]
	data[데이터 위험]
	control[제어 위험]
	structural[구조적 위험]
	
	pipeline_hazard --- data 
	pipeline_hazard ---	control
	pipeline_hazard --- structural
```

  

**데이터 위험**

데이터 위험(Data Hazard)은 명령어 파이프라인에서 발생하는 위험 중 하나입니다. 데이터 위험은 명령어들 사이에서 데이터가 올바른 순서로 처리되지 않아 발생하는 문제입니다. 예를 들어, 다음과 같은 두 개의 명령어가 있을 때,

```Plain
ADD R1, R2, R3
SUB R4, R1, R5
```

두 번째 명령어는 첫 번째 명령어에서 사용된 레지스터 R1이 필요합니다. 하지만 첫 번째 명령어가 실행되고 있는 도중에 두 번째 명령어가 실행되면 R1의 값이 바뀌어 있을 수 있습니다. 이러한 경우에는 데이터 위험이 발생합니다.

데이터 위험을 해결하기 위해서는 여러 가지 방법이 있습니다. 가장 흔한 방법은 Forwarding이라는 기법을 사용하는 것입니다. Forwarding은 명령어 파이프라인에서 데이터를 이동시켜서 데이터 위험을 해결하는 방법입니다. 이를 통해 CPU의 성능을 향상시킬 수 있습니다.

**제어 위험**

제어 위험(Control Hazard)은 명령어 파이프라인에서 발생하는 위험 중 하나입니다. 제어 위험은 분기 명령어나 점프 명령어 등이 실행될 때 발생합니다. 이러한 명령어들은 다음에 실행될 명령어의 주소를 변경하기 때문입니다. 만약 파이프라인에서 분기 명령어가 실행되기 전에 다음 명령어가 이미 실행되고 있다면, 분기 명령어가 실행될 때까지 이전 명령어를 무시해야 합니다. 이러한 경우에는 제어 위험이 발생합니다.

제어 위험을 해결하기 위해서는 여러 가지 방법이 있습니다. 가장 흔한 방법은 Branch Prediction이라는 기법을 사용하는 것입니다. Branch Prediction은 분기 명령어가 실행될 때 실행될 다음 명령어의 주소를 미리 예측하는 방법입니다. 이를 통해 CPU의 성능을 향상시킬 수 있습니다.

```Plain
flowchart LR
	pipeline_hazard[파이프라인 위험]
	data[데이터 위험]
	control[제어 위험]
	structural[구조적 위험]

	pipeline_hazard --- data
	pipeline_hazard ---	control
	pipeline_hazard --- structural
```

**구조적 위험**

구조적 위험(Structural Hazard)은 명령어 파이프라인에서 발생하는 위험 중 하나입니다. 구조적 위험은 명령어들 사이에서 하드웨어 자원(레지스터, ALU 등)을 사용하는 데 충돌이 일어나는 경우입니다. 예를 들어, 하나의 명령어에서 ALU를 사용하는데 다른 명령어에서 ALU를 사용하려고 할 때 구조적 위험이 발생합니다.

구조적 위험을 해결하기 위해서는 하드웨어 자원을 더욱 효율적으로 할당하는 방법이 있습니다. 이러한 방법을 통해 CPU의 성능을 향상시킬 수 있습니다.

  

### 슈퍼스칼라

슈퍼스칼라는 CPU에서 명령어를 병렬로 처리하는 기법 중 하나입니다. 슈퍼스칼라는 명령어를 여러 개 동시에 실행할 수 있도록 설계되어 있습니다. 이를 위해 하나 이상의 명령어를 동시에 실행할 수 있는 하드웨어적인 기능을 가지고 있습니다. 슈퍼스칼라 아키텍처는 대부분의 현대적인 CPU에서 사용되고 있습니다.

슈퍼스칼라 아키텍처에서는 명령어 파이프라인을 사용하여 명령어를 병렬로 처리합니다. 이를 위해 하나의 명령어를 여러 개의 단계로 나누어 처리합니다. 이러한 방식으로 여러 개의 명령어를 동시에 처리할 수 있습니다.

슈퍼스칼라는 명령어를 더욱 효율적으로 처리할 수 있도록 설계되어 있습니다. 이를 위해 명령어 파이프라인과 함께 여러 가지 기술을 사용합니다. 이러한 기술은 명령어를 처리하는 데 필요한 하드웨어의 수를 줄이고, 명령어를 더욱 빠르게 처리할 수 있도록 합니다. 슈퍼스칼라는 명령어를 더욱 빠르게 처리할 수 있도록 함으로써 CPU의 성능을 향상시키는 데 큰 역할을 합니다.

  

### 비순차적 명령어 처리

비순차적 명령어 처리(Out-of-order Execution)는 명령어들의 실행 순서를 변경하여, 더욱 효율적으로 명령어를 처리하는 기법입니다. 비순차적 명령어 처리는 명령어 파이프라인에서 발생하는 몇 가지 문제를 해결할 수 있습니다. 예를 들어, 명령어 실행 시간이 서로 다른 경우, 파이프라인에 차단이 발생할 수 있는데, 이를 비순차적 명령어 처리로 해결할 수 있습니다.

비순차적 명령어 처리는 명령어 실행 순서를 변경하는 것으로, 다음과 같은 과정으로 이루어집니다.

1. 명령어 인출
2. 명령어 디코딩
3. 명령어 실행
4. 결과 저장

명령어가 실행되는 동안, 다른 명령어를 실행할 수 있는 유휴한 하드웨어 자원이 있을 경우, 비순차적 명령어 처리는 이를 활용하여 더욱 빠르게 명령어를 처리합니다. 이를 통해 CPU의 성능을 높일 수 있습니다.

비순차적 명령어 처리는 명령어의 실행 순서를 변경하기 때문에, 실행 결과가 순차적인 명령어 처리와 다를 수 있습니다. 이러한 문제를 해결하기 위해, 비순차적 명령어 처리는 레지스터 리네이밍이라는 기법을 사용합니다. 레지스터 리네이밍은 명령어에서 사용되는 레지스터의 이름을 임시 레지스터로 변경하는 방법입니다. 이를 통해 명령어 간에 레지스터 이름 충돌이 발생하지 않도록 합니다.

비순차적 명령어 처리는 명령어 파이프라인에서 발생하는 여러 가지 문제를 해결할 수 있습니다. 이를 통해 CPU의 성능을 높일 수 있습니다.

## 05.3 CISC와 RISC

### 명령어 집합

컴퓨터 아키텍처에서 명령어 집합(Instruction Set)은 컴퓨터가 해석하고 실행하는 명령어의 모음입니다. 명령어 집합은 CPU가 지원하는 명령어의 종류와 형식을 정의합니다. 컴퓨터 아키텍처에서는 명령어 집합의 크기와 복잡도가 아키텍처의 분류에 영향을 미칩니다.

명령어 집합은 크게 CISC(Complex Instruction Set Computer)와 RISC(Reduced Instruction Set Computer)로 나뉩니다. CISC 아키텍처는 명령어가 복잡하고 다양하며, 하나의 명령어가 여러 동작을 수행할 수 있습니다. 이에 반해 RISC 아키텍처는 명령어가 단순하고 일관성이 있으며, 최소한의 기능만을 수행합니다.

CISC 아키텍처는 명령어가 복잡하고 다양하여, 명령어 집합의 크기가 크고, 명령어의 실행 시간이 길어집니다. 이에 비해 RISC 아키텍처는 명령어가 단순하고 일관성이 있으며, 명령어의 실행 시간이 짧아집니다. 이러한 이유로 RISC 아키텍처는 CISC 아키텍처에 비해 더욱 빠른 성능을 보입니다.

명령어 집합은 컴퓨터 아키텍처에서 중요한 역할을 합니다. 명령어 집합의 크기와 복잡도는 CPU의 성능과 아키텍처의 분류에 영향을 미치며, 명령어 집합의 설계는 컴퓨터 아키텍처의 특성을 결정합니다.

  

### CICS

CISC(Complex Instruction Set Computer) 아키텍처는 명령어가 복잡하고 다양하여, 명령어 집합의 크기가 크고, 명령어의 실행 시간이 길어집니다. 이러한 복잡한 명령어들을 지원하기 위해 하드웨어 구조가 복잡하고 대부분의 명령어가 여러개의 사이클을 사용하여 수행됩니다. CISC 아키텍처에서는 명령어 하나가 여러개의 동작을 수행하는 경우가 많습니다.

  

### RISC

RISC(Reduced Instruction Set Computer) 아키텍처는 명령어가 단순하고 일관성이 있으며, 명령어의 실행 시간이 짧아집니다. 이러한 이유로 RISC 아키텍처는 CISC 아키텍처에 비해 더욱 빠른 성능을 보이며, 고정 길이 명령어를 활용합니다.