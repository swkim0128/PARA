---
type: Java
archive: false
---
### 내부클래스(inner class)란?

---

내부 클래스는 클래스 내에 선언된 클래스이다. 클래스에 다른 클래스 선언하는 이유는 간단하다. 두 클래스가 서로 긴밀한 관계에 있기 때문이다.

> ▶︎ 내부 클래스의 장점  
> - 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.  
> - 코드의 복잡성을 줄일 수 있다.(캡슐화)  

```Java
class A {    // 외부 클래스
	// ...
	class B {    // 내부 클래스
		// ...
	}
	// ...
}
```

내부 클래스인 B는 외부 클래스인 A를 제외하고는 다른 클래스에서 잘 사용되지 않는 것이여야 한다.

내부 클래스는 주로 AWT나 Swing과 같은 GUI어플리케이션의 이벤트처리 외에는 잘 사용하지 않을 정도로 사용빈도가 높지 않다.

  

### 내부 클래스의 종류와 특징

---

내부 클래스의 종류는 변수의 선언위치에 따른 종류와 같다. 내부 클래스는 마치 변수를 선언하는 것과 같은 위치에 선언할 수 있으며, 변수의 선언위치에 따라 인스턴스변수, 클래스변수(static변수), 지역변수로 구분되는 것과 같이 내부 클래스도 선언위치에 따라 구분되어 진다.

인스턴스 클래스  
(instance class)  

스태틱 클래스  
(static class)  

지역 클래스  
(local class)  

익명 클래스  
(anonymous class)  

외부 클래스의 멤버변수 선언위치에 선언하여, 외부 클래스의 인스턴스멤버처럼 다루어진다. 주로 외부 클래스의 인스턴스멤버들과 관련된 작업에 사용된 목적으로 선언된다.

외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 Static멤버처럼 다루어진다. 주로 외부 클래스의 static멤버, 특히 static메서드에서 사용될 목적으로 선언된다.

외부 클래스의 메서드나 초기화블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.

클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)

  

### 내부 클래스의 선언

---

변수가 선언된 위치에 따라 인스턴스변수, 클래스변수(static변수), 지역변수로 나뉘듯이 내부 클래스도 이와 마찬가지로 선언된 위치에 다라 나뉜다. 그리고, 각 내부 클래스의 선언위치에 따라 같은 선언위치의 변수와 동일한 유효범위(scope)와 접근성(accessiblility)을 갖는다.

```Java
class Outer {
	class InstanceInner {}
	static class StaticInner {}

	void myMethod() {
		class LocalIner {}
	}
}
```

  

### 내부 클래스의 제어자와 접근성

---

내부 클래스가 외부 클래스의 멤버와 같이 간주되고, 이스턴스멤버와 static멤버간의 큐칙이 내부 클래스에도 똑같이 적용된다.

내부 클래스도 클래스이기 때무에 abstract나 final과 같은 제어자를 사용할 수 있을 뿐만 아니라, 멤버변수들처럼 private, protected와 같은 접근데어자도 사용이 가능하다.

내부 클래스 중에서 스태틱 클래스(StaticInner)만 static멤버를 가질 수 있다. 드문 경우지만 내부 클래스에 static변수를 선언해야한다면 스태틱 클래스로 선언해야한다.  
다만 final과 static이 동시에 붙은 변수는 상수(constant)이므로 모든 내부 클래스에서 정의가 가능하다.  

  

### 익명 클래스(anonymous class)

---

익명 클래스는 특이하게도 다른 내부 클래스들과는 달리 이름이 없다. 클래스의 선언과 객체의 생성을 동시에 하기 때문에 단 한번만 사용될 수 있고 오직 하나의 객체만을 생성할 수 있는 일회용 클래스이다.

> new 조상클래스이름() {  
> // 멤버 선언  
> }  
>   
> new 구현인터페이스이름() {  
> // 멤버 선언  
> }  

이름이 없기 때문에 생성자도 가질 수 없으며, 조상클래스의 이름이나 구현하고자 하는 인터페이스의 이름을 사용해서 정의기 때문에 하나의 클래스로 상속받는 동시에 인터페이슬르 구현하거나 둘 이상의 인터페이스를 구현할 수 없다. 오로지 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있다.

  

```Java
class InnerEx6 {
	Object iv = new Ojbect() { void method() {} };        // 익명클래스
	static Object cv = new Objet() { void method() {} };  // 익명클래스

void myMethod() {
	Object lv = new Object() { void method() {} };        // 익명클래스
	}
}
```