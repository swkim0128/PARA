---
type: ComputerArchitecture
archive: false
---
04.1 ALU와 제어장치

ALU

제어장치

04.2 레지스터

레지스터

특정 레지스터를 이용한 주소 지정 방식 1. 스택 주소 지정 방식

특정 레지스터를 이용한 주소 지정 방식 2. 변위 주소 지정 방식

04.3 명령어 사이클과 인터럽트

명령어 사이클

인터럽트

## 04.1 ALU와 제어장치

### ALU

ALU(산술논리장치)는 중앙처리장치(CPU)의 일부로서, 두 개의 이진수를 입력으로 받아 논리 연산(AND, OR, NOT, XOR 등)과 산술 연산(덧셈, 뺄셈, 곱셈, 나눗셈 등)을 수행합니다. 이 연산 결과는 레지스터에 저장되거나, 논리 연산의 경우에는 조건 레지스터에 저장됩니다. 제어장치(Control Unit)는 CPU에서 ALU를 제어하며, ALU에서 수행할 연산을 명령어에서 가져온 제어 신호에 따라 결정합니다.

```Mermaid
graph LR
A[입력 A] -->|ALU| B[출력]
C[입력 B] -->|ALU| B
D[제어 장치] -->|제어 신호| ALU
ALU -->|결과값| E[레지스터]
ALU -->|플래그| F[플래그 레지스터]
```

### 제어장치

제어장치(Control Unit)는 CPU의 일부로서, 명령어에서 가져온 제어 신호에 따라 중앙처리장치(CPU) 내의 다른 구성 요소들, 특히 ALU(산술논리장치)를 제어합니다. 제어장치는 CPU의 작동 주기를 제어하고, 명령어 사이클을 처리하는 데 중요한 역할을 합니다.

```Mermaid
graph LR
D -->|제어 신호| C[레지스터]
D[제어 장치] -->|제어 신호| ALU
D -->|제어 신호| B[메모리]
D -->|제어 신호| E[입출력장치]
R[명령어 레지스터] -->|명령어| D
K[''] -->|클럭| D
F[플래그 레지스터] -->|플래그| D
```

제어장치가 받아들이는 정보

첫째, 제어장치는 클럭 신호를 받아드립니다.

둘째, 제어장치는 ‘해석해야 할 명령어’를 받아드립니다.

셋째, 제어장치는 플래그 레지스터 속 플래그 값을 받아드립니다.

넷째, 제어장치는 시스템 버스, 그 중에서 제어 버스로 전달된 제어 신호를 받아드립니다.

## 04.2 레지스터

### 레지스터

레지스터(Register)는 중앙처리장치(CPU) 내부에 존재하는 작고 빠른 메모리입니다. 레지스터는 CPU가 프로그램을 실행하는 동안 데이터를 일시적으로 저장할 수 있게 해줍니다. CPU가 처리하는 데이터는 대개 레지스터에 저장되어 처리됩니다.

대부분의 CPU는 다음과 같은 레지스터를 가지고 있습니다.

- 프로그램 카운터(Program Counter): 다음 실행할 명령어의 주소를 가리킵니다.
- 명령어 레지스터 : 다음에 실행할 명령어의 주소를 저장합니다. CPU는 명령어 레지스터에 저장된 주소를 참조하여 다음에 실행할 명령어를 가져와 실행합니다.
- 메모리 주소 레지스터 : 메모리에서 데이터를 가져오거나 메모리에 데이터를 저장할 때 사용되는 주소를 저장합니다.
- 메모리 버퍼 레지스터 : 데이터를 읽어오거나 쓸 때 사용합니다. CPU는 메모리 주소 레지스터에 저장된 주소를 참조하여 메모리에 접근하고, 메모리 버퍼 레지스터에 데이터를 읽거나 씁니다. 그 후 이 레지스터의 값을 다른 레지스터나 연산 장치 등에 전달하여 데이터 처리를 수행합니다.
- 플래그 레지스터 : 연산 결과에 대한 정보를 저장합니다. CPU가 수행하는 연산의 결과가 양수인지, 음수인지, 0인지 등에 대한 정보를 저장합니다.
- 범용 레지스터 : CPU가 데이터를 처리하는 과정에서 일시적으로 값을 저장할 수 있는 일반적인 목적의 레지스터입니다. CPU는 범용 레지스터에서 데이터를 읽어들이고, 이를 처리한 후에 다시 레지스터에 저장합니다. 범용 레지스터는 여러 명령어에서 사용될 수 있습니다.
- 스택 포인터(Stack Pointer): 스택의 최상위 항목을 가리킵니다.
- 베이스 레지스터(Base Register): 메모리에 접근하기 위한 기준 주소를 저장합니다.

### 특정 레지스터를 이용한 주소 지정 방식 1. 스택 주소 지정 방식

스택 주소 지정 방식(Stack Addressing Mode)은 스택(Stack)이라는 메모리 영역을 이용하는 방식입니다. 스택은 데이터를 저장하는 영역으로, 가장 최근에 저장된 데이터가 가장 먼저 읽혀지는 후입선출(Last-In-First-Out) 구조를 가지고 있습니다.

스택 주소 지정 방식은 명령어 내에서 스택 포인터(Stack Pointer) 레지스터를 이용하여 스택에 데이터를 저장하거나 읽어오는 방식입니다. 스택 포인터 레지스터는 현재 스택의 최상위 항목의 주소를 가리키고 있습니다.

### 특정 레지스터를 이용한 주소 지정 방식 2. 변위 주소 지정 방식

변위 주소 지정 방식(Displacement Addressing Mode)은 기본 주소(Base Address)와 변위(Displacement)를 더하여 실제 주소를 계산하는 방식입니다. 이 방식은 명령어에서 직접적으로 주소를 지정하지 않고, 레지스터 등 다른 정보를 이용하여 주소를 계산합니다. 예를 들어, 메모리의 100번지부터 8바이트를 처리하려면, 기본 주소로 100번지를 이용하고, 변위로 8을 이용하여 실제 주소를 계산합니다. 변위는 부호화된 8바이트 정수로 지정되며, 기본 주소와 더해져서 실제 주소를 계산합니다.

변위 주소 지정 방식은 상대적으로 복잡한 계산을 필요로 하기 때문에, 주로 반복문과 같은 반복작업을 수행하는 경우에 사용됩니다. 예를 들어, 배열의 모든 요소를 처리할 때, 반복문에서 인덱스를 이용하여 다음 요소의 주소를 계산할 때 변위 주소 지정 방식을 사용할 수 있습니다.

**상대 주소 지정 방식**

**베이스 레지스터 주소 지정 방식**

## 04.3 명령어 사이클과 인터럽트

### 명령어 사이클

명령어 사이클(Instruction Cycle)은 CPU가 명령어를 처리하는 데 필요한 과정을 말합니다. CPU는 메모리에서 명령어를 가져오고, 해당 명령어를 해석하고, 실행하는 과정을 거칩니다. 이러한 과정을 명령어 사이클이라고 합니다.

명령어 사이클은 크게 다음과 같은 과정으로 나눌 수 있습니다.

1. Fetch(인출 사이클): 다음 실행할 명령어를 메모리에서 가져옵니다.
2. Execute(실행 사이클): 명령어를 실행합니다.
3. Indirect(간접 사이클): 명령어에서 직접적으로 주소를 지정하지 않고, 다른 주소를 이용하여 주소를 계산하는 방식입니다.

### 인터럽트

인터럽트(Interrupt)는 CPU가 프로그램을 실행하는 도중에 다른 장치나 외부에서 발생한 이벤트에 의해 실행 중인 프로그램의 흐름이 일시적으로 중단되고, 우선순위가 높은 이벤트를 먼저 처리한 후, 다시 실행 중인 프로그램으로 돌아가서 실행을 계속하는 기술입니다.

인터럽트는 CPU가 다른 작업을 수행하다가 중요한 이벤트가 발생하면, 해당 이벤트를 처리하기 위해 현재 실행 중인 작업을 일시적으로 멈추고, 해당 이벤트를 우선적으로 처리합니다. 이후에는 이전 작업을 계속할 수 있도록 다시 복귀합니다.

인터럽트는 보통 하드웨어 인터럽트와 소프트웨어 인터럽트로 구분됩니다. 하드웨어 인터럽트는 CPU 외부에서 발생하는 이벤트로, 예를 들어, 입출력 장치로부터의 입력 신호나 타이머 신호 등이 있습니다. 소프트웨어 인터럽트는 CPU 내부에서 발생하는 이벤트로, 예를 들어, 프로그램 내에서 명시적으로 인터럽트를 호출하는 경우가 있습니다.

인터럽트는 CPU가 실행 중인 작업을 일시적으로 멈추고, 다른 작업을 처리하는 기술이기 때문에, 시스템 성능에 영향을 미칩니다. 따라서 인터럽트의 수를 최소화하고, 인터럽트 처리 시간을 최소화하는 것이 중요합니다.

인터럽트의 처리는 인터럽트 서비스 루틴(Interrupt Service Routine, ISR)이라는 특별한 프로그램이 담당합니다. ISR은 인터럽트가 발생하면, 해당 인터럽트를 우선순위에 따라 처리하고, 다시 이전 작업으로 돌아가는 역할을 합니다.

```Mermaid
graph LR;
    A[인터럽트] --> B["동기 인터럽트\n(예외)"]
		B --> F[폴트]
		B --> G[트랩]
		B --> J[중단]
		B --> K[소프트웨어 인터럽트]
    A --> C["비동기 인터럽트\n(하드웨어 인터럽트)"]
		C --> D[막을 수 있는 인터럽트]
		C --> E[막을 수 없는 인터럽트]
```

동기 인터럽트(Synchronous Interrupt)는 CPU가 실행 중인 프로그램 내에서 명령어를 실행하는 도중에 발생하는 인터럽트로, 예를 들어, 명령어 실행 도중에 발생한 오버플로우나 제로 디바이드 등의 오류가 있습니다. 이러한 인터럽트는 예측 가능하며, CPU가 다음 작업을 수행하기 전에 반드시 처리해야 합니다. 따라서 동기 인터럽트는 CPU가 인터럽트를 처리하는 동안에는 다른 작업을 수행할 수 없습니다.

비동기 인터럽트(Asynchronous Interrupt)는 CPU 외부에서 발생하는 인터럽트로, 예를 들어, 입출력 장치로부터의 입력 신호나 타이머 신호 등이 있습니다. 이러한 인터럽트는 예측할 수 없으며, 언제든지 발생할 수 있습니다. 따라서 CPU는 인터럽트가 발생하면, 현재 실행 중인 작업을 중단하고, 해당 인터럽트를 우선적으로 처리합니다. 이후에는 이전 작업을 계속할 수 있도록 다시 복귀합니다.

비동기 인터럽트는 CPU가 실행 중인 작업을 일시적으로 멈추고, 다른 작업을 처리하는 기술이기 때문에, 시스템 성능에 영향을 미칩니다. 따라서 인터럽트의 수를 최소화하고, 인터럽트 처리 시간을 최소화하는 것이 중요합니다.